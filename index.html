<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Agent Workflow Interface</title>
    
    <!-- Preload critical resources -->
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" as="style">
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" as="style">
    
    <!-- Primary stylesheets with fallback handling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" 
          onerror="handleStyleError(this, 'Bootstrap')">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet"
          onerror="handleStyleError(this, 'Font Awesome')">
          
    <!-- Fallback styles for offline mode -->
    <style id="fallback-styles">
        /* Minimal fallback styles if CDN resources fail */
        .cdn-error { 
            padding: 1rem;
            margin: 1rem 0;
            border: 1px solid #dc3545;
            border-radius: 4px;
            color: #dc3545;
            background: #f8d7da;
        }
    </style>

    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --success-color: #2ecc71;
            --error-color: #e74c3c;
            --background-color: #f8f9fa;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--primary-color);
            line-height: 1.6;
        }

        .navbar {
            background-color: var(--primary-color);
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .navbar-brand {
            color: white !important;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .main-container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        .card {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 1.5rem;
            border: none;
        }

        .card-header {
            background-color: var(--primary-color);
            color: white;
            border-radius: 10px 10px 0 0 !important;
            padding: 1rem;
            font-weight: bold;
        }

        .form-control {
            border-radius: 5px;
            border: 2px solid #ddd;
            padding: 0.75rem;
            transition: all 0.3s ease;
        }

        .form-control:focus {
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 0.2rem rgba(52, 152, 219, 0.25);
        }

        .btn-primary {
            background-color: var(--secondary-color);
            border: none;
            padding: 0.75rem 1.5rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }

        .message {
            padding: 1rem;
            margin: 0.5rem 0;
            border-radius: 5px;
            border-left: 4px solid var(--secondary-color);
            background-color: rgba(52, 152, 219, 0.1);
        }

        .message.error {
            border-left-color: var(--error-color);
            background-color: rgba(231, 76, 60, 0.1);
        }

        .message.success {
            border-left-color: var(--success-color);
            background-color: rgba(46, 204, 113, 0.1);
        }

        .workflow-status {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 15px;
            font-size: 0.875rem;
            font-weight: bold;
        }

        .status-running {
            background-color: #fff3cd;
            color: #856404;
        }

        .status-completed {
            background-color: #d4edda;
            color: #155724;
        }

        .status-error {
            background-color: #f8d7da;
            color: #721c24;
        }

        .agent-card {
            border-left: 4px solid var(--secondary-color);
            margin-bottom: 1rem;
        }

        .visualization-container {
            height: 400px;
            background-color: white;
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        #network-graph {
            width: 100%;
            height: 100%;
        }

        .loading-spinner {
            display: none;
            text-align: center;
            padding: 2rem;
        }

        .tooltip-inner {
            max-width: 300px;
        }

        .log-entry {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.875rem;
            padding: 0.5rem;
            border-bottom: 1px solid #eee;
        }

        .timestamp {
            color: #666;
            margin-right: 0.5rem;
        }

        #error-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1050;
        }

        #messages {
            overflow: auto;
            max-height: 300px;
        }

        .demo-mode-banner {
            background-color: #ffc107;
            color: #000;
            text-align: center;
            padding: 0.5rem;
            font-weight: bold;
            display: none;
        }

        .offline-mode {
            opacity: 0.7;
            pointer-events: none;
        }

        .offline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .offline-message {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
        }

        .resource-error {
            padding: 0.5rem;
            margin: 0.5rem 0;
            border-radius: 4px;
            font-size: 0.875rem;
            display: none;
        }

        #static-demo-controls {
            display: none;
            margin-top: 1rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .demo-speed-control {
            width: 100%;
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <!-- Demo Mode Banner -->
    <div class="demo-mode-banner" id="demo-mode-banner">
        Running in Demo Mode - No Backend Connection Required
    </div>

    <!-- Offline Overlay -->
    <div class="offline-overlay" id="offline-overlay">
        <div class="offline-message">
            <h4>You're Offline</h4>
            <p>Some features may be limited. Check your internet connection.</p>
            <button class="btn btn-primary" onclick="activateStaticDemo()">
                Continue in Demo Mode
            </button>
        </div>
    </div>

    <!-- Resource Error Container -->
    <div id="resource-errors" class="container mt-3"></div>

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">
                <i class="fas fa-robot me-2"></i>Multi-Agent Workflow System
            </a>
            <div class="d-flex">
                <span class="text-light" id="connection-status">
                    <i class="fas fa-circle text-success me-2"></i>Connected
                </span>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <div class="main-container">
        <div class="row">
            <!-- Workflow Control Panel -->
            <div class="col-md-4">
                <div class="card">
                    <div class="card-header">
                        <i class="fas fa-cogs me-2"></i>Workflow Control
                    </div>
                    <div class="card-body">
                        <form id="workflow-form">
                            <div class="mb-3">
                                <label for="input-data" class="form-label">Input Data</label>
                                <textarea class="form-control" id="input-data" rows="4" placeholder="Enter JSON input data" required></textarea>
                                <div class="form-text">Example: {"query": "analyze market trends", "parameters": {"timeframe": "1w"}}</div>
                            </div>
                            <div class="mb-3">
                                <label for="agent-selection" class="form-label">Select Agents</label>
                                <select class="form-select" id="agent-selection" multiple required>
                                    <option value="professor_athena">Professor Athena (Research)</option>
                                    <option value="dr_milgrim">Dr. Milgrim (Analysis)</option>
                                    <option value="yaat">YAAT (Task Execution)</option>
                                </select>
                                <div class="form-text">Hold Ctrl/Cmd to select multiple agents</div>
                            </div>
                            <div class="mb-3">
                                <label for="workflow-type" class="form-label">Workflow Type</label>
                                <select class="form-select" id="workflow-type" required>
                                    <option value="sequential">Sequential</option>
                                    <option value="parallel">Parallel</option>
                                    <option value="hybrid">Hybrid</option>
                                </select>
                            </div>
                            <button type="submit" class="btn btn-primary w-100" id="start-workflow-btn">
                                <i class="fas fa-play me-2"></i>Start Workflow
                            </button>
                        </form>
                    </div>
                </div>

                <!-- Workflow Status -->
                <div class="card">
                    <div class="card-header">
                        <i class="fas fa-info-circle me-2"></i>Current Status
                    </div>
                    <div class="card-body">
                        <p><strong>State ID:</strong> <span id="state-id">-</span></p>
                        <p><strong>Status:</strong> <span id="workflow-status" class="workflow-status">Not Started</span></p>
                        <p><strong>Active Agents:</strong> <span id="active-agents">0</span></p>
                        <p><strong>Messages Processed:</strong> <span id="messages-count">0</span></p>
                    </div>
                </div>
            </div>

            <!-- Visualization Panel -->
            <div class="col-md-8">
                <div class="card">
                    <div class="card-header">
                        <i class="fas fa-project-diagram me-2"></i>Workflow Visualization
                    </div>
                    <div class="card-body">
                        <div class="visualization-container">
                            <div id="network-graph"></div>
                        </div>
                    </div>
                </div>

                <!-- Message Log -->
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <div>
                            <i class="fas fa-comments me-2"></i>Message Log
                        </div>
                        <button class="btn btn-sm btn-outline-light" id="clear-log" title="Clear message log">
                            <i class="fas fa-trash-alt"></i>
                        </button>
                    </div>
                    <div class="card-body">
                        <div id="messages"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Data Store Panel -->
        <div class="row mt-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <i class="fas fa-database me-2"></i>Data Store
                    </div>
                    <div class="card-body">
                        <pre id="data-store" class="bg-light p-3 rounded"></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Static Demo Controls -->
        <div id="static-demo-controls" class="card">
            <div class="card-header">
                <i class="fas fa-theater-masks me-2"></i>Demo Controls
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="demo-speed" class="form-label">Simulation Speed</label>
                    <input type="range" class="demo-speed-control" id="demo-speed" min="0.5" max="2" step="0.1" value="1">
                    <span id="speed-value">1x</span>
                </div>
                <button class="btn btn-secondary" onclick="resetDemo()">
                    <i class="fas fa-redo me-2"></i>Reset Demo
                </button>
            </div>
        </div>
    </div>

    <!-- Loading Spinner -->
    <div class="loading-spinner" id="loading-spinner">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Processing workflow...</p>
    </div>

    <!-- Error Toast -->
    <div class="toast" id="error-toast" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-header bg-danger text-white">
            <i class="fas fa-exclamation-circle me-2"></i>
            <strong class="me-auto">Error</strong>
            <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body" id="error-message"></div>
    </div>

    <!-- Scripts -->
    <!-- Load scripts with error handling -->
    <script>
        // Resource loading error handling
        function handleStyleError(stylesheet, name) {
            const errorsContainer = document.getElementById('resource-errors');
            const error = document.createElement('div');
            error.className = 'resource-error alert alert-warning';
            error.innerHTML = `Failed to load ${name}. Some styles may be missing.`;
            errorsContainer.appendChild(error);
        }

        function handleScriptError(script, name) {
            const errorsContainer = document.getElementById('resource-errors');
            const error = document.createElement('div');
            error.className = 'resource-error alert alert-danger';
            error.innerHTML = `Failed to load ${name}. Some features may not work.`;
            errorsContainer.appendChild(error);
            
            if (name === 'Visualization Library') {
                document.getElementById('network-graph').innerHTML = 
                    '<div class="alert alert-warning">Visualization unavailable. Please check your connection.</div>';
            }
        }

        // Dynamically load scripts with error handling
        function loadScript(url, name) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = url;
                script.onload = resolve;
                script.onerror = () => {
                    handleScriptError(script, name);
                    reject(new Error(`Failed to load ${name}`));
                };
                document.body.appendChild(script);
            });
        }
    </script>

    <!-- Load required libraries -->
    <script>
        Promise.all([
            loadScript('https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js', 'Bootstrap'),
            loadScript('https://cdn.jsdelivr.net/npm/vis-network@9.1.2/dist/vis-network.min.js', 'Visualization Library'),
            loadScript('https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js', 'Utilities')
        ]).catch(error => {
            console.error('Failed to load some required resources:', error);
        });
    </script>

    <!-- Main application script -->
    <script>
        // Configuration with enhanced settings
        const CONFIG = {
            API_BASE_URL: '/Langchain-Agents/api',
            DEMO_MODE: false,
            UPDATE_INTERVAL: 1000,
            MAX_RETRIES: 3,
            RETRY_DELAY: 2000,
            WORKFLOW_TYPES: {
                sequential: 'Sequential execution of agents',
                parallel: 'Parallel execution with coordination',
                hybrid: 'Dynamic execution based on task'
            },
            PERFORMANCE_METRICS: {
                enabled: true,
                sampleRate: 1000,
                maxDataPoints: 100
            },
            DATABASE: {
                poolSize: 5,
                timeout: 5000,
                retryInterval: 1000
            },
            AGENT_CONFIGS: {
                professor_athena: {
                    maxConcurrentTasks: 3,
                    specialties: ['research', 'analysis', 'planning'],
                    responseTimeout: 30000
                },
                dr_milgrim: {
                    maxConcurrentTasks: 2,
                    specialties: ['data_processing', 'pattern_recognition'],
                    responseTimeout: 20000
                },
                yaat: {
                    maxConcurrentTasks: 5,
                    specialties: ['task_execution', 'coordination'],
                    responseTimeout: 15000
                }
            }
        };

        // Enhanced demo data with more realistic scenarios
        const DEMO_DATA = {
            agents: [
                { 
                    id: 'professor_athena',
                    name: 'Professor Athena',
                    status: 'active',
                    tasks_completed: 5,
                    specialty: 'Research & Analysis',
                    confidence: 0.92,
                    performance_metrics: {
                        avg_response_time: 1200,
                        success_rate: 0.95,
                        task_complexity: 0.8
                    },
                    current_tasks: []
                },
                { 
                    id: 'dr_milgrim',
                    name: 'Dr. Milgrim',
                    status: 'active',
                    tasks_completed: 3,
                    specialty: 'Data Processing',
                    confidence: 0.87
                },
                { 
                    id: 'yaat',
                    name: 'YAAT',
                    status: 'active',
                    tasks_completed: 4,
                    specialty: 'Task Execution',
                    confidence: 0.95
                }
            ],
            scenarios: [
                {
                    name: 'Market Analysis',
                    description: 'Analyze market trends and generate insights',
                    workflow_type: 'sequential',
                    stages: [
                        { name: 'Data Collection', agent: 'professor_athena', duration: 2000 },
                        { name: 'Pattern Analysis', agent: 'dr_milgrim', duration: 3000 },
                        { name: 'Report Generation', agent: 'yaat', duration: 1500 }
                    ]
                },
                {
                    name: 'Real-time Monitoring',
                    description: 'Monitor and respond to system events',
                    workflow_type: 'parallel',
                    stages: [
                        { name: 'Event Processing', agent: 'dr_milgrim', duration: 1000 },
                        { name: 'Alert Generation', agent: 'yaat', duration: 800 },
                        { name: 'Response Planning', agent: 'professor_athena', duration: 1500 }
                    ]
                }
            ],
            performance_data: {
                cpu_usage: [],
                memory_usage: [],
                response_times: [],
                error_rates: []
            }
        };

        // Global state
        const state = {
            demoMode: false,
            demoSpeed: 1,
            currentStateId: null,
            networkInstance: null,
            updateInterval: null,
            retryCount: 0,
            processedMessages: new Set(),
            selectedWorkflowType: 'sequential'
        };

        // Initialize network visualization with error handling
        function initializeNetwork() {
            const container = document.getElementById('network-graph');
            if (typeof vis === 'undefined') {
                container.innerHTML = '<div class="alert alert-warning">Visualization library not available</div>';
                return;
            }

            try {
                const options = {
                    nodes: {
                        shape: 'dot',
                        size: 30,
                        font: {
                            size: 14,
                            color: '#333'
                        },
                        borderWidth: 2,
                        shadow: true
                    },
                    edges: {
                        width: 2,
                        color: { inherit: 'from' },
                        smooth: {
                            type: 'continuous'
                        },
                        arrows: {
                            to: { enabled: true, scaleFactor: 1 }
                        }
                    },
                    physics: {
                        stabilization: false,
                        barnesHut: {
                            gravitationalConstant: -80000,
                            springConstant: 0.001,
                            springLength: 200
                        }
                    }
                };

                const data = {
                    nodes: new vis.DataSet([]),
                    edges: new vis.DataSet([])
                };

                state.networkInstance = new vis.Network(container, data, options);
            } catch (error) {
                container.innerHTML = `<div class="alert alert-danger">Failed to initialize visualization: ${error.message}</div>`;
            }
        }

        // Update network visualization
        function updateVisualization(agents, messages) {
            if (!state.networkInstance) return;

            const nodes = new vis.DataSet();
            const edges = new vis.DataSet();

            // Add agent nodes
            agents.forEach(agent => {
                nodes.add({
                    id: agent.id,
                    label: agent.name,
                    color: {
                        background: '#3498db',
                        border: '#2980b9'
                    },
                    title: `Status: ${agent.status}<br>Tasks: ${agent.tasks_completed}`
                });
            });

            // Add message edges
            messages.forEach((msg, index) => {
                edges.add({
                    id: index,
                    from: msg.from,
                    to: msg.to,
                    label: msg.type,
                    arrows: 'to'
                });
            });

            state.networkInstance.setData({ nodes, edges });
        }

        // Add message to log
        function addMessage(message, type = 'info') {
            const messagesDiv = document.getElementById('messages');
            const messageElement = document.createElement('div');
            messageElement.classList.add('log-entry');
            
            const timestamp = new Date().toLocaleTimeString();
            messageElement.innerHTML = `
                <span class="timestamp">[${timestamp}]</span>
                <span class="message ${type}">${message}</span>
            `;
            
            messagesDiv.appendChild(messageElement);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // Update workflow status
        function updateStatus(status) {
            const statusElement = document.getElementById('workflow-status');
            statusElement.className = 'workflow-status';
            
            switch(status.toLowerCase()) {
                case 'running':
                    statusElement.classList.add('status-running');
                    statusElement.textContent = 'Running';
                    break;
                case 'completed':
                    statusElement.classList.add('status-completed');
                    statusElement.textContent = 'Completed';
                    break;
                case 'error':
                    statusElement.classList.add('status-error');
                    statusElement.textContent = 'Error';
                    break;
                default:
                    statusElement.textContent = status;
            }
        }

        // Show error message
        function showError(message) {
            document.getElementById('error-message').textContent = message;
            new bootstrap.Toast(document.getElementById('error-toast')).show();
        }

        // Static demo mode functions
        function activateStaticDemo() {
            state.demoMode = true;
            document.getElementById('demo-mode-banner').style.display = 'block';
            document.getElementById('static-demo-controls').style.display = 'block';
            document.getElementById('offline-overlay').style.display = 'none';
            
            // Update UI for demo mode
            updateVisualization(DEMO_DATA.agents, DEMO_DATA.messages);
            updateStatus('running');
            addMessage('Demo mode activated', 'info');
            
            // Start demo simulation
            simulateDemoWorkflow();
        }

        function simulateDemoWorkflow() {
            let step = 0;
            const maxSteps = 10;
            const messageTypes = ['query', 'analysis', 'response', 'update', 'result'];
            const taskTypes = [
                'Initializing research parameters',
                'Gathering data samples',
                'Processing information',
                'Analyzing patterns',
                'Generating insights',
                'Validating results',
                'Preparing report'
            ];
            
            state.updateInterval = setInterval(() => {
                step++;
                // Update progress
                const progress = (step / maxSteps) * 100;
                DEMO_DATA.data_store.progress = progress;
                DEMO_DATA.data_store.current_task = taskTypes[Math.floor((taskTypes.length * step) / maxSteps)];
                
                // Generate realistic message
                const fromAgent = DEMO_DATA.agents[Math.floor(Math.random() * DEMO_DATA.agents.length)];
                const toAgent = DEMO_DATA.agents[Math.floor(Math.random() * DEMO_DATA.agents.length)];
                const messageType = messageTypes[Math.floor(Math.random() * messageTypes.length)];
                
                const newMessage = {
                    id: Date.now(),
                    from: fromAgent.id,
                    to: toAgent.id,
                    type: messageType,
                    content: `${fromAgent.name} is ${DEMO_DATA.data_store.current_task.toLowerCase()}`
                };
                
                DEMO_DATA.messages.push(newMessage);
                
                // Update UI with more detailed information
                updateVisualization(DEMO_DATA.agents, DEMO_DATA.messages);
                document.getElementById('messages-count').textContent = DEMO_DATA.messages.length;
                document.getElementById('data-store').textContent = JSON.stringify(DEMO_DATA.data_store, null, 2);
                addMessage(newMessage.content, messageType === 'error' ? 'error' : 'info');
                
                // Update agent status randomly
                DEMO_DATA.agents.forEach(agent => {
                    agent.tasks_completed += Math.random() > 0.7 ? 1 : 0;
                    agent.confidence = Math.max(0.5, Math.min(1, agent.confidence + (Math.random() - 0.5) * 0.1));
                });
                
                if (step >= maxSteps) {
                    clearInterval(state.updateInterval);
                    updateStatus('completed');
                    addMessage('Demo workflow completed successfully', 'success');
                    document.getElementById('loading-spinner').style.display = 'none';
                }
            }, CONFIG.UPDATE_INTERVAL * state.demoSpeed);
        }

        function resetDemo() {
            clearInterval(state.updateInterval);
            DEMO_DATA.messages = DEMO_DATA.messages.slice(0, 3);
            DEMO_DATA.data_store.progress = 0;
            updateVisualization(DEMO_DATA.agents, DEMO_DATA.messages);
            updateStatus('not_started');
            document.getElementById('messages').innerHTML = '';
            addMessage('Demo reset', 'info');
        }

        // Enhanced error handling and retry logic
        async function fetchWithRetry(url, options = {}) {
            for (let i = 0; i < CONFIG.MAX_RETRIES; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    if (i === CONFIG.MAX_RETRIES - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY));
                }
            }
        }

        // Enhanced connection check with offline mode handling
        async function checkConnection() {
            try {
                const response = await fetch(`${CONFIG.API_BASE_URL}/health/`);
                if (!response.ok) throw new Error('API unavailable');
                
                document.getElementById('connection-status').innerHTML = `
                    <i class="fas fa-circle text-success me-2"></i>Connected
                `;
                return true;
            } catch (error) {
                document.getElementById('connection-status').innerHTML = `
                    <i class="fas fa-circle text-danger me-2"></i>Disconnected
                    <small class="text-warning">(${error.message})</small>
                `;
                
                // Show offline overlay if not in demo mode
                if (!state.demoMode) {
                    document.getElementById('offline-overlay').style.display = 'flex';
                }
                return false;
            }
        }

        // Production mode utilities
        const ProductionMode = {
            async initializeDatabase() {
                try {
                    const response = await fetchWithRetry(`${CONFIG.API_BASE_URL}/database/initialize`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(CONFIG.DATABASE)
                    });
                    return response.success;
                } catch (error) {
                    console.error('Database initialization failed:', error);
                    return false;
                }
            },

            async getAgentMetrics(agentId) {
                try {
                    return await fetchWithRetry(`${CONFIG.API_BASE_URL}/agents/${agentId}/metrics`);
                } catch (error) {
                    console.error(`Failed to fetch metrics for agent ${agentId}:`, error);
                    return null;
                }
            },

            async updateWorkflowState(stateId, updates) {
                try {
                    return await fetchWithRetry(`${CONFIG.API_BASE_URL}/workflow/${stateId}/update`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(updates)
                    });
                } catch (error) {
                    console.error('Failed to update workflow state:', error);
                    return false;
                }
            },

            startPerformanceMonitoring() {
                if (!CONFIG.PERFORMANCE_METRICS.enabled) return;
                
                const metrics = {
                    timestamps: [],
                    cpu: [],
                    memory: [],
                    responseTime: []
                };

                return setInterval(async () => {
                    try {
                        const perfData = await fetchWithRetry(`${CONFIG.API_BASE_URL}/system/metrics`);
                        
                        metrics.timestamps.push(Date.now());
                        metrics.cpu.push(perfData.cpu_usage);
                        metrics.memory.push(perfData.memory_usage);
                        metrics.responseTime.push(perfData.avg_response_time);

                        // Keep only the last N data points
                        if (metrics.timestamps.length > CONFIG.PERFORMANCE_METRICS.maxDataPoints) {
                            metrics.timestamps.shift();
                            metrics.cpu.shift();
                            metrics.memory.shift();
                            metrics.responseTime.shift();
                        }

                        // Update performance visualization
                        updatePerformanceCharts(metrics);
                    } catch (error) {
                        console.error('Performance monitoring error:', error);
                    }
                }, CONFIG.PERFORMANCE_METRICS.sampleRate);
            }
        };

        // Demo mode utilities
        const DemoMode = {
            scenarios: DEMO_DATA.scenarios,
            currentScenario: null,
            
            async startScenario(scenarioName) {
                const scenario = this.scenarios.find(s => s.name === scenarioName);
                if (!scenario) return false;

                this.currentScenario = scenario;
                let currentStage = 0;

                const runStage = async () => {
                    if (currentStage >= scenario.stages.length) {
                        addMessage(`Scenario "${scenarioName}" completed`, 'success');
                        return;
                    }

                    const stage = scenario.stages[currentStage];
                    const agent = DEMO_DATA.agents.find(a => a.id === stage.agent);

                    addMessage(`${agent.name} starting stage: ${stage.name}`, 'info');
                    
                    // Simulate stage execution
                    await new Promise(resolve => setTimeout(resolve, stage.duration));
                    
                    // Update agent metrics
                    agent.tasks_completed++;
                    agent.performance_metrics.avg_response_time = 
                        (agent.performance_metrics.avg_response_time + stage.duration) / 2;

                    addMessage(`${agent.name} completed stage: ${stage.name}`, 'success');
                    
                    currentStage++;
                    await runStage();
                };

                await runStage();
                return true;
            },

            generateRandomMetrics() {
                return {
                    cpu: Math.random() * 100,
                    memory: 50 + Math.random() * 50,
                    responseTime: 100 + Math.random() * 900
                };
            },

            simulateAgentInteraction() {
                const randomAgent = () => 
                    DEMO_DATA.agents[Math.floor(Math.random() * DEMO_DATA.agents.length)];
                
                setInterval(() => {
                    const agent1 = randomAgent();
                    const agent2 = randomAgent();
                    
                    if (agent1 !== agent2) {
                        const interaction = {
                            from: agent1.id,
                            to: agent2.id,
                            type: Math.random() > 0.5 ? 'query' : 'response',
                            content: `${agent1.name} interacting with ${agent2.name}`
                        };
                        
                        DEMO_DATA.messages.push(interaction);
                        updateVisualization(DEMO_DATA.agents, DEMO_DATA.messages);
                        addMessage(interaction.content, 'info');
                    }
                }, 2000);
            }
        };

        // Enhanced visualization utilities
        function updatePerformanceCharts(metrics) {
            // Implementation would go here - using a charting library like Chart.js
            // This is just a placeholder for the actual implementation
            console.log('Updating performance charts with metrics:', metrics);
        }

        // Enhanced workflow state management
        async function fetchWorkflowState() {
            if (!state.currentStateId) return;

            try {
                const data = await fetchWithRetry(`${CONFIG.API_BASE_URL}/workflow/${state.currentStateId}/`);
                
                // Update UI elements
                document.getElementById('state-id').textContent = state.currentStateId;
                document.getElementById('active-agents').textContent = data.active_agents.length;
                document.getElementById('messages-count').textContent = data.messages.length;
                
                // Update performance metrics if available
                if (data.performance_metrics) {
                    updatePerformanceCharts(data.performance_metrics);
                }
                
                // Update agent status and metrics
                await Promise.all(data.active_agents.map(async (agent) => {
                    const agentMetrics = await ProductionMode.getAgentMetrics(agent.id);
                    if (agentMetrics) {
                        agent.performance_metrics = agentMetrics;
                    }
                }));
                
                // Update visualization with enhanced metrics
                updateVisualization(data.active_agents, data.messages);
                
                // Update status and data store
                updateStatus(data.status);
                document.getElementById('data-store').textContent = 
                    JSON.stringify(data.data_store, null, 2);
                
                // Process new messages
                data.messages.forEach(msg => {
                    if (!state.processedMessages.has(msg.id)) {
                        addMessage(msg.content || `${msg.from} to ${msg.to}: ${msg.type}`, 
                                 msg.type === 'error' ? 'error' : 'info');
                        state.processedMessages.add(msg.id);
                    }
                });
                
                // Handle workflow completion
                if (data.status.toLowerCase() === 'completed') {
                    clearInterval(state.updateInterval);
                    document.getElementById('loading-spinner').style.display = 'none';
                    showSuccess('Workflow completed successfully!');
                    
                    // Save final state to database
                    await ProductionMode.updateWorkflowState(state.currentStateId, {
                        status: 'completed',
                        completion_time: new Date().toISOString(),
                        final_metrics: data.performance_metrics
                    });
                }
            } catch (error) {
                showError(`Error fetching workflow state: ${error.message}`);
                if (state.retryCount++ >= CONFIG.MAX_RETRIES) {
                    clearInterval(state.updateInterval);
                    document.getElementById('loading-spinner').style.display = 'none';
                    showError('Max retries reached. Switching to demo mode...');
                    activateStaticDemo();
                }
            }
        }

        // Initialize the application
        async function initializeApplication() {
            try {
                // Initialize database connection
                const dbInitialized = await ProductionMode.initializeDatabase();
                if (!dbInitialized) {
                    showError('Failed to initialize database. Switching to demo mode...');
                    activateStaticDemo();
                    return;
                }

                // Start performance monitoring
                ProductionMode.startPerformanceMonitoring();

                // Initialize network visualization
                initializeNetwork();

                // Setup event listeners
                setupEventListeners();

                // Initial connection check
                await checkConnection();
            } catch (error) {
                console.error('Application initialization failed:', error);
                showError('Failed to initialize application. Please refresh the page.');
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // ... existing event listener setup code ...

            // Add scenario selection handler for demo mode
            document.getElementById('scenario-select')?.addEventListener('change', (e) => {
                if (state.demoMode) {
                    DemoMode.startScenario(e.target.value);
                }
            });
        }

        // Start the application when the DOM is ready
        document.addEventListener('DOMContentLoaded', initializeApplication);

        // Global error boundary
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Global error:', { msg, url, lineNo, columnNo, error });
            showError(`An error occurred: ${msg}`);
            return false;
        };

        // Performance monitoring
        const PerformanceMonitor = {
            metrics: {
                errors: 0,
                warnings: 0,
                apiCalls: 0,
                avgResponseTime: 0,
                totalResponseTime: 0
            },

            startTime: Date.now(),

            logError(error) {
                this.metrics.errors++;
                this.updateDashboard();
                console.error('Monitored error:', error);
            },

            logWarning(warning) {
                this.metrics.warnings++;
                this.updateDashboard();
                console.warn('Monitored warning:', warning);
            },

            logApiCall(duration) {
                this.metrics.apiCalls++;
                this.metrics.totalResponseTime += duration;
                this.metrics.avgResponseTime = this.metrics.totalResponseTime / this.metrics.apiCalls;
                this.updateDashboard();
            },

            getUptime() {
                return Math.floor((Date.now() - this.startTime) / 1000);
            },

            updateDashboard() {
                if (!CONFIG.PERFORMANCE_METRICS.enabled) return;

                const metrics = {
                    uptime: this.getUptime(),
                    errors: this.metrics.errors,
                    warnings: this.metrics.warnings,
                    apiCalls: this.metrics.apiCalls,
                    avgResponseTime: Math.round(this.metrics.avgResponseTime)
                };

                // Update performance metrics in UI
                document.getElementById('uptime').textContent = `${metrics.uptime}s`;
                document.getElementById('error-count').textContent = metrics.errors;
                document.getElementById('warning-count').textContent = metrics.warnings;
                document.getElementById('api-calls').textContent = metrics.apiCalls;
                document.getElementById('avg-response-time').textContent = `${metrics.avgResponseTime}ms`;

                // Update status indicators
                const healthStatus = document.getElementById('health-status');
                if (metrics.errors > 10) {
                    healthStatus.className = 'badge bg-danger';
                    healthStatus.textContent = 'Critical';
                } else if (metrics.errors > 5) {
                    healthStatus.className = 'badge bg-warning';
                    healthStatus.textContent = 'Warning';
                } else {
                    healthStatus.className = 'badge bg-success';
                    healthStatus.textContent = 'Healthy';
                }

                // Log to console if significant changes
                if (metrics.errors > 0 && metrics.errors % 5 === 0) {
                    console.warn('Error threshold reached:', metrics);
                }
            },

            reset() {
                this.metrics = {
                    errors: 0,
                    warnings: 0,
                    apiCalls: 0,
                    avgResponseTime: 0,
                    totalResponseTime: 0
                };
                this.startTime = Date.now();
                this.updateDashboard();
            }
        };

        // Enhanced fetch with performance monitoring
        async function monitoredFetch(url, options = {}) {
            const startTime = Date.now();
            try {
                const response = await fetch(url, options);
                const duration = Date.now() - startTime;
                PerformanceMonitor.logApiCall(duration);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response;
            } catch (error) {
                PerformanceMonitor.logError(error);
                throw error;
            }
        }

        // Replace fetch calls with monitored version
        const originalFetchWithRetry = fetchWithRetry;
        fetchWithRetry = async function(url, options = {}) {
            try {
                return await originalFetchWithRetry(url, {
                    ...options,
                    fetch: monitoredFetch
                });
            } catch (error) {
                PerformanceMonitor.logError(error);
                throw error;
            }
        };

        // Enhanced error handling
        const originalShowError = showError;
        showError = function(message) {
            PerformanceMonitor.logError(new Error(message));
            originalShowError(message);
        };

        // Start performance monitoring
        document.addEventListener('DOMContentLoaded', () => {
            if (CONFIG.PERFORMANCE_METRICS.enabled) {
                console.log('Performance monitoring started');
                setInterval(() => {
                    PerformanceMonitor.updateDashboard();
                }, CONFIG.PERFORMANCE_METRICS.sampleRate);
            }
        });

        // Export monitoring interface for debugging
        window.DEBUG = {
            monitor: PerformanceMonitor,
            state: state,
            config: CONFIG
        };

    </script>
</body>
</html>